1. 키워드란 무엇인가?

자바 프로그래밍 문법을 위한 단어 (예: public, class, void....)


2. "2의 보수법"이란?

2진수 양수에서 음수로 바꾸려면, 양수의 2의 보수를 취한다음 1을 더함.
ㄴ 보수란? 10진수(9<->1, 7<->3), 2진수(0<->1)

예: 

+5      =  00000101  -> 양수5의 값

2의 보수 : 11111010

1을 더함 : 11111011  -> 음수5의 값

============================ (-5의 값 획득)
즉, 양수5 + 음수5 는

    00000101
 + 11111011
---------------
=1 00000000  
여기서 맨 앞 올림수1은 버림
즉, 00000000 = 0.



3. 컴퓨터에서 음의 정수 표현방법에 대하여 설명하시오.
2의 보수법 이용



4. -5가 컴퓨터에서의 2진수 값을 나타내시오.
11111011 (과정은 문제2 참고)



5. 실수에서 오차가 생기는 원인은 무엇인가?

실수는 무한대임.
컴퓨터는 메모리에 무한대의 실수를 올려야 하는데,
메모리는 유한하기 때문에 무한대인 실수 전체를 담지 못함.

그럼? -> 실수의 범위를 정해서, 범위 내에서 *표현 가능한 수를 정해놓고,
정해진 수 근처의 무한한 실수는 근삿값으로 대체. (최대한 가까운 실수의 표현이 저장된다.)

*표현 가능한 수 정하는 방법 
: 공식이 있음. 수식 // 말할 때 '부.지.가'라고 부르심(공식암기x)




6. 실수의 표현법은(고정소수법, 부동소수법)을 설명하시오.

예: 
고정소수법 : 0.123

부동소수법 : 1.234 x 10^-1

-> 표현방식의 차이



7. 정밀도란 무엇인가요?

실수는 무한대이기 때문에 정해진 범위 내에서 표현 가능토록 저장된 수의 값 중 
가장 근삿값으로 그 무한한 실수의 표현을 대체함. 

그 과정에서 표현 가능한 수 사이의 간격이 넓으면 넓을수록 
근삿값의 범위가 넓어지기 때문에 더 많은 근삿값을 포함하게 되므로 정밀도가 떨어짐.

그러므로, 실수를 표현할 때 float 형 보다 double형을 선택하는 것이 좋다.

Why? float는 소수점 이하 6자리 표현 가능
        double는 소수점 이하 15자리 표현 가능

cf. 1. 여기서 정밀도는 값을 대입했을 때의 정밀도이며, 연산 시의 정밀도가 아님.
    2. double형 또한 오차가 기본적으로 생길 수 밖에 없다.
 


8. a)상수란 무엇이며 b)변수와의 차이는?

a) 상수란? 항상 같은 수. 변하지 않는 수.
변수 선언 앞에 final붙는 것. 
한번 값을 할당하면(초기화하면) 변하지 않는다.


 가. 상수 이름은 대문자로. 전체가 대문자.
 예: final int EXAMPLE = 1;

 나. 한번 값을 대입하면 초기화 x

 다. 상수의 활용
 - 언제 사용하나?
   프로그래밍 하다가 누군가가 중간에 값을 변경시키면 안 되는 것을 상수로.  예: PI값
~상수 활용을 잘 하는 사람이 되자!~



b) 변수와의 차이?
상수는 한 번 할당하면 변하지 않음.
변수는 계속 초기화 가능. 변할 수 있음.




9. 초기화란 무엇인가?

초기화란 "변수" 초기화를 의미.
해당 변수에 선언한 뒤 처음으로 값을 넣는 것.


10. 리터럴이란 무엇인가요?

상수의 일종인데.. 
자료형을 기반으로 표현이 되는 상수


가. 정수형 상수의 표현 방법 

int num1 = 123;	 // 10진수 표현 - 그냥 숫자만
int num2 = 0123;	 // 8진수 표현 - 숫자 앞에 0
int num3 = 0x123;	 // 16진수 표현 - 숫자 앞에 0x
int num4 = 0B111;  // 2진수 표현 - 숫자 앞에 0B 또는 0b
(근데 java에서 굳이 2진수, 8진수, 16진수로 표현 x)
int num5 = 1_23_456_789;  	// 원하는 위치에 언더바 삽입 가능 	


나. 실수형 상수 표현 방법

System.out.println(3.000499);    // 자료형이 그냥 double이면 d안붙여도 되는데,
System.out.println(3.000499f);   //  float형으로 표현하려면 f붙여줘야 함.
System.out.println(3147486358L);  // long형으로 표현
System.out.println(3.4e3);       // 3.4 x 10^3 를 표현



11. 아래의 내용이 에러가 나는 이유와 수정방법은?
System.out.println(3147483647 + 3147483648);

  가. 이유

  자바에서 메모리의 기본이 4바이트(int : +-21억) 인데,
  해당 연산의 결과값은 그 범위를 넘음. (integer number too large.)

  나. 수정 방법

  숫자뒤에 L(또는 l)를 붙여서 범위 커버 가능한 long형 상수로 표현해줘야 함.




12. 자동 형변환과 명시적 형변환에 대하여 설명하시오.

<자동 형 변환>

: 크고, 소숫점 보존하는 방향으로.

  가. 자료형의 크기가 큰 방향으로 형 변환

  나. 정수 < 실수형 우선으로 형 변환 
  -> long(8byte) < float(4byte) 우선

  Why? 1. float형이 이미 long형에 대한 범위 커버 가능
          2. float형의 소숫점 커버해야함

[자동 형 변환의 예]

int num1 = 1;
long num2 = 8934757834L;
sysout(num1+num2); -> long형으로 자동으로 맞춰짐


<명시적 형 변환>

= 강제적 형 변환
: 자동 형 변환의 조건에는 부합하지 않지만, 강제로 형 변환
(아닌거 아는데.. 내가 책임질 게 우리 형 변환 한번 해보자.. <- 이런 느낌)

방식: short result = (short)(num1+num2); 

[명시적 형 변환의 예]

double pi = 3.14;
int result = (int)pi;
sysout(result);
------------------------컴파일
결과값: 3 



13. 아래의 에러가 나는 이유를 설명하고 수정하시오.
    	int a = 3;
    	int b = 4;
    	
    	double result = a / b;
    	
    	System.out.println(result);

가. 이유

: int끼리 연산 했으므로 결과값도 int라서 소숫점 이하는 잘라버림. 
근데 그 result값을 돌리니까 당연히 0만남음.

나. 수정 방법 (2가지)

   1) 명시적 형 변환
	int a = 3;
	int b = 4;
		
	double result = (double)a/b;

    2) 데이터타입 수정
	double a = 3;
	int b = 4;		//또는 double b = 4;
		
	double result = a/b;




14. 이스퀘이프 시퀀스의 종류를 나열하고 기능을 설명하시오.

Escape Sequences? 화면상의 어떠한 상황 또는 상태를 표현하기 위해 약속된 문자
이스퀘이프 시퀀스를 입력하면 해당 상태를 적용한 값이 출력된다.


<종류> (* 여기서 \는 역슬래시)

'\b' : 백스페이스 
'\t'  : 탭
'\\' : 백슬래시
'\''  : 작은 따옴표
'\"'  : 큰 따옴표
'\n' : 개행 = 엔터
'\r' : 캐리지 리턴(carriage return), 맨 앞으로 커서가 옮겨지고 입력됨



15.아래의 출력결과를 확인하고, 130이 나오는 이유를 설명하시오.
System.out.println('A' + 'A')

 가. 출력 결과: 130

 나. 이유

 'A'는 문자. 2byte의 char형 메모리에 'A'를 넣으면, 'A'에 해당하는 문자표(여기서는 알파벳이므로 아스키 코드)에 있는 코드값이 들어가게 된다. 
아스키 코드표 상 'A'의 코드값은 65 ---> 인코딩
따라서, 'A' + 'A' = 65 + 65이므로, 결과값은 130.


