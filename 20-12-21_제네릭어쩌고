# 21~ 23

1.제네릭 클래스의 타입 인자 제한하는 방법과 효과는?
:

인스턴스 생성 시 타입 인자로 Number 또는 이를 상속하는 클래스만 올 수 있음
ex) class Box<T extends Number> {...} 
=> 와 같이 Number 클래스를 상속하면 기본형으로 타입을 제한
즉, String, Apple과 같은 타입은 들어오지 못함.


2.아래와 같이 출력값이 나오도록 프로그래밍 하시오.
class DDBoxDemo {
    public static void main(String[] args) {
        DBox<String, Integer> box1 = new DBox<>();
        box1.set("Apple", 25);

        DBox<String, Integer> box2 = new DBox<>();
        box2.set("Orange", 33);
        
        DDBox<DBox<String, Integer>, DBox<String, Integer>> ddbox = new DDBox<>();
        ddbox.set(box1, box2);

        System.out.println(ddbox);
    }
}

==================
Apple & 25
Orange & 33

:

3.아래와 같이 출력값이 나오도록 프로그래밍 하시오.
    public static void main(String[] args) {
        Box<Integer> box1 = new Box<>();
        box1.set(99);

        Box<Integer> box2 = new Box<>();
        box2.set(55);

        System.out.println(box1.get() + " & " + box2.get());
        swapBox(box1, box2);
        System.out.println(box1.get() + " & " + box2.get());
    }
==========
99 & 55
55 & 99

<풀이>
package java_12_21;

class BoxHW<T> {

	private T ob;

	public T get() {
		return ob;
	}

	public void set(T ob) {
		this.ob = ob;
	}
}

public class BoxHWMain {

	private static <T> void swapBox(BoxHW<T> box1, BoxHW<T> box2) {
		T tmp = box1.get();
		box1.set(box2.get());
		box2.set(tmp);
	}

	public static void main(String[] args) {
		BoxHW<Integer> box1 = new BoxHW<>();
		box1.set(99);

		BoxHW<Integer> box2 = new BoxHW<>();
		box2.set(55);

		System.out.println(box1.get() + " & " + box2.get());
		swapBox(box1, box2);
		System.out.println(box1.get() + " & " + box2.get());
	}
}

<결과>
99 & 55
55 & 99


4.지네릭 메소드에 대하여 설명하시오.
: 함수 앞에 제네릭<>이 왔다.
클래스 전체가 아닌 해당 함수만 제네릭으로 정의됨.


5.와일드 카드와 상한 제한, 하한 제한에 대하여 설명하시오.
- 와일드 카드:
- 상한 제한된 와일드 카드:
- 하한 제한된 와일드 카드:


6.아래가 에러가 나는 이유를 설명하시오.
public static void inBox(Box<? super Toy> box, Toy n) {
   box.set(n);   // 넣는 것! OK!
   Toy myToy = box.get();   // 꺼내는 것! Error!
}

: 본 경우는 하한 제한된 와일드 카드의 예시이다.
"<? super Toy>" 부분에는 부모 클래스의 Box<Plastic>과, 
상속받은 자식 클래스의 Box<Toy>가 인스턴스 인자로 올 수 있다.
이때, Toy myToy = box.get(); 는 return값으로 ob가 오는데,
만약 Box<T> 가 Box<Plastic>인 경우에는 
데이터 타입 Toy인 myToy라는 이름의 방에서 데이터 타입이 Plastic인 ob 방으로 선을 
보내게 된다. (객체 생성) 
따라서, 자식 = 부모가 되므로 폴리몰티즘 위반이므로 에러가 난다.


7.아래와 같이 메소드 오버로딩이 되지 않는 이유는?
// 다음 두 메소드는 오버로딩 인정 안됨.
   public static void outBox(Box<? extends Toy> box) {...}
   public static void outBox(Box<? extends Robot> box) {...}

:


8.아래의 결과가 나오도록 프로그래밍을 완성하시오.
 public static void main(String[] args) {
        Box<Integer> box1 = new Box<>();
        box1.set(24);

        Box<String> box2 = new Box<>();
        box2.set("Poly");

        if(compBox(box1, 25))
            System.out.println("상자 안에 25 저장");

        if(compBox(box2, "Moly"))
            System.out.println("상자 안에 Moly 저장");
        
        System.out.println(box1.get());
        System.out.println(box2.get());
    }

=======
24
Poly

<풀이>
package java_12_21;

 class Box5<T> {

	private T ob;

	public T get() {
		return ob;
	}

	public void set(T ob) {
		this.ob = ob;
	}
}

public class BoxMolyPoly {

	private static <T> boolean compBox(Box5<T> box1, int i) {
		return false;
	}

	private static <T> boolean compBox(Box5<T> box2, String string) {
		return false;
	}

	public static void main(String[] args) {

		Box5<Integer> box1 = new Box5<>();
		box1.set(24);

		Box5<String> box2 = new Box5<>();
		box2.set("Poly");

		if (compBox(box1, 25))
			System.out.println("상자 안에 25 저장");

		if (compBox(box2, "Moly"))
			System.out.println("상자 안에 Moly 저장");

		System.out.println(box1.get());
		System.out.println(box2.get());
	}

}


<결과>
24
Poly


9.콜렉션 프레임워크란?
:

